# Arduino-AD-Multichannel-Multitasking-Interrupt

(C) 2019 Dipl. Phys. Helmut Weber<br>
 
 Reading AD-Valures, which are generated by interrupts<br>
 ATMega328p: UNO, NANO, ...<br>
 

 Sketch uses 3872 bytes (12%) of program storage space. Maximum is 30720 bytes.
 Global variables use 388 bytes (18%) of dynamic memory, leaving 1660 bytes for local variables. Maximum is 2048 bytes.
 
 <h3>Introduction</h3>

 Realtime Operating systems are the prefered tool for most measurements.<br>
 ChibiOS and derivatives are running on the Arduino UNO.<br>
 But sometimes a TickTime of 1 ms is too long.<br>
 
 The goal is:
 Measuring AD values at 3 channels (or more) as fast as possible and print them ready for Arduino-Plotter.
 3 Channels mean: Free running is not possible because we have to change the channels.
 
 As an example a HEART-BEAT sensor is used.The data line is connected to A0, A1, A2 - but 3 different <br>
 AD-Sources could be used.
 
 The 3 lines are filtered because they are noisy. Different filter factors are used.
 
  <h3>Interrupts</h3>
 Here I show another approach using Interrupts.
 Three curves are red from the AD-converter using AD-Interrupt-Conversion-Ready<br>
 Up to 6000 conversions per second are done.<br>
 The values are filtered and may be displayed using "Serial Plotter"<br>
 
  <h3>Multitasking</h3>
 Besides "loop" 2 tasks are running in the backgrund"<br>
 One of them every 1 ms, the other more often but with more jitter !
 
 
  <h3>Filter</h3>
 AD-Values for CHNUM channels are red using AD-Ready-Interrupts.
 One Channel after the other is red starting with channel 0 again.
 
 This is done in the background without any intervention of the LOOP
 
 The values are averaged for IRQ_SAMPLES  samples
 
 This is the code for averaging:
    > avv=(float)analogVal;    
    > av[Channel] = (Alpha[Channel]*oldVal[Channel]) + ((1-Alpha[Channel])*avv);    
    > oldVal[Channel]=av[Channel];    
 
 The sense is to get most samples possible, build an average over IRQ_SAMPLES value 
 and set the IrqReadyFlag.
 Then the Measurement is stopped and the "Busy" Flag is set.
 
 LOOP or any other function has to read (and print/ plot) the values.
 
 After that the next points will be generated in the background again with:
 
   > IrqReadyFlag = 0;    <br>
   > Busy = false;    <br>
   > ADCSRA |= B01000000; // Start next conversion    <br>
 
  <h3>Example-HEART-BEAT</h3>
 Here is an example of a HEART-BEAT-Sensor. 
 
 ![Demo](./Demo.jpg?raw=true "Demo HEAART-BEAT")

 Blue - original 
 
 Green - soft filtered
 
 Red - hard filtered<br
 
 The channels got an offset for better display.
 
 Filtereing implies a phase shift !
 
  <h3>Timing</h3>
 
 We get about **5500 (filtered) samples per second**.
 
 - with 10 IRQ_SAMPLES there are 200 Time Points per second (180 with Serial.print)
 
 Enough to show the details of HEART-BEAT
 
 3 Channels with 10 samples = 30 samples in 5,4 ms for a Time Point. 
 
 There is plenty of room to do other things in LOOP !
 
 ![Timing](./Timing.jpg?raw=true "Timing")

 
 @author Helmut Weber
 
